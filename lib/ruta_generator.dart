import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';
import 'package:glob/glob.dart';

/// Builder for generating Ruta routes
class RutaBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'$package$': ['.ruta/server.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final mainAssetId = AssetId(buildStep.inputId.package, 'lib/main.dart');
    final bool hasEntrypoint = await buildStep.canRead(mainAssetId);
    LibraryElement? library;
    bool hasRun = false;
    bool hasInit = false;

    if (hasEntrypoint) {
      final isLib = await buildStep.resolver.isLibrary(mainAssetId);
      if (!isLib) {
        throw Exception('lib/main.dart must be a valid Dart library.');
      }

      library = await buildStep.resolver.libraryFor(mainAssetId);
      hasRun = library.topLevelElements.any(
        (e) =>
            e.name == 'run' && e is FunctionElement && e.parameters.length == 3,
      );
      hasInit = library.topLevelElements
          .any((e) => e.name == 'init' && e is FunctionElement);
    }

    final routes = <String>[];
    final imports = <String>{
      "'package:ruta/ruta.dart'",
      "'dart:io'",
      "'package:get_it/get_it.dart'",
      "'package:ruta/open_api.dart'",
      "'package:shelf_swagger_ui/shelf_swagger_ui.dart'",
    };

    if (hasEntrypoint) {
      imports.add(
        "'package:${buildStep.inputId.package}/main.dart' as entrypoint",
      );
    }

    final routeDefinitions = <String, List<String>>{};

    final assetIds = await buildStep.findAssets(Glob('lib/**.dart')).toList();
    for (final assetId in assetIds) {
      if (!await buildStep.canRead(assetId)) {
        continue;
      }

      final isLib = await buildStep.resolver.isLibrary(assetId);
      if (!isLib) {
        continue;
      }

      final library = await buildStep.resolver.libraryFor(assetId);

      for (final element in library.definingCompilationUnit.classes) {
        if (element.metadata.any((meta) {
          final constant = meta.computeConstantValue();
          final typeName = constant?.type?.element?.name;
          return typeName == 'RutaRoute';
        })) {
          final routeType = element.allSupertypes.firstWhereOrNull(
            (t) =>
                t.element.name == 'Route' && t.element.library.name == 'ruta',
          );
          if (routeType == null) {
            throw Exception('${element.name} must implement Route');
          }

          final className = element.name;
          imports.add("'package:${element.source.uri.path}'");
          final constructor = element.constructors
                  .firstWhereOrNull((c) => c.isDefaultConstructor) ??
              element.constructors.first;

          final dependencies = constructor.parameters.map((param) {
            if (param.isNamed) {
              return '${param.name}: getIt()';
            } else {
              return 'getIt()';
            }
          }).join(', ');

          final routeInstance = dependencies.isEmpty
              ? '$className()'
              : '$className($dependencies)';

          routes.add(routeInstance);

          final endpointGetters = element.accessors
              .where(
                (accessor) =>
                    accessor.isGetter &&
                    accessor.returnType.element?.name == 'Endpoint' &&
                    accessor.returnType.element?.library?.name == 'ruta',
              )
              .map((getter) => getter.name)
              .toList();

          routeDefinitions[routeInstance] = endpointGetters;
        }
      }
    }

    final buffer = StringBuffer()
      ..writeln('// Generated by ruta_generator. DO NOT EDIT.')
      ..writeln();

    for (final imp in imports) {
      buffer.writeln('import $imp;');
    }

    buffer
      ..writeln()
      ..writeln('final getIt = GetIt.instance;')
      ..writeln();

    if (!hasEntrypoint) {
      buffer.writeln(
        '// Warning: file lib/main.dart was not found',
      );
    }
    if (!hasInit) {
      buffer
        ..writeln('// Warning: init method not found in main.dart')
        ..writeln(
          '// Please add this method to lib/main.dart with the following signature:',
        )
        ..writeln('// Future<void> init() {...}')
        ..writeln();
    }

    if (!hasRun) {
      buffer
        ..writeln('// Warning: run method not found in main.dart')
        ..writeln(
          '// Please add this method to lib/main.dart with the following signature:',
        )
        ..writeln(
          '// Future<HttpServer> run(Handler Function() handlerCallback, InternetAddress address, int port) {...}',
        )
        ..writeln();
    }

    buffer
      ..writeln('Handler createRouter() {')
      ..writeln('  final router = Router();')
      ..writeln('  try {');

    int count = 1;
    final List<String> routeNames = [];
    for (final routeInstance in routes) {
      final List<String> endpoints = routeDefinitions[routeInstance]!;
      final String className = 'route${count++}';
      routeNames.add(className);

      buffer
        ..writeln('    final $className = $routeInstance;')
        ..writeln('    $className.endpoints = [');
      for (final endpoint in endpoints) {
        buffer.writeln('      $className.$endpoint,');
      }
      buffer.writeln('    ];');
    }

    buffer.writeln('    final routes = <Route>[');

    for (final name in routeNames) {
      buffer.writeln('      $name,');
    }

    buffer
      ..writeln('    ];')
      ..writeln()
      ..writeln('    for (final route in routes) {')
      ..writeln(r"      router.mount('/${route.name}', route.build());")
      ..writeln('    }')
      ..writeln()
      ..writeln('    OpenApiSpec? spec;')
      ..writeln('    try {')
      ..writeln('      spec = getIt.get<OpenApiSpec>();')
      ..writeln('    } catch (e) {')
      ..writeln(
        "      print('Register OpenApiSpec class inside getIt to have openapi documentation');",
      )
      ..writeln('    }')
      ..writeln()
      ..writeln('    if (spec != null) {')
      ..writeln('      OpenApiGenerator.generate(spec, routes);')
      ..writeln('      final File openapiSpec = File(".ruta/openapi.json");')
      ..writeln(
        '      final swaggerUi = SwaggerUI.fromFile(openapiSpec, title: spec.info.title);',
      )
      ..writeln(
        "      router.mount('/api-docs', fromShelfHandler(swaggerUi.call));",
      )
      ..writeln('    }')
      ..writeln('  } catch (e) {')
      ..writeln(r"    print('Error initializing routes: $e');")
      ..writeln('  }')
      ..writeln('  return router.call;')
      ..writeln('}')
      ..writeln()
      ..writeln(
        'Future<HttpServer> createServer(InternetAddress address, int port) {',
      );

    if (hasRun) {
      buffer.writeln('  return entrypoint.run(createRouter, address, port);');
    } else {
      buffer.writeln('  return defaultRutaRun(createRouter, address, port);');
    }

    buffer
      ..writeln('}')
      ..writeln()
      ..writeln('void main() async {')
      ..writeln('  getIt.allowReassignment = true;');

    if (hasInit) {
      buffer.writeln('  await entrypoint.init();');
    }

    buffer
      ..writeln()
      ..writeln('  bool isFirstLaunch = true;')
      ..writeln()
      ..writeln('  hotReload(() async {')
      ..writeln(
        "    final port = int.tryParse(Platform.environment['PORT'] ?? '8080') ?? 8080;",
      )
      ..writeln(
        '    final server = await createServer(InternetAddress.anyIPv4, port);',
      )
      ..writeln('    if (isFirstLaunch) {')
      ..writeln(
        r"      print('Server running on http://localhost:${server.port}');",
      )
      ..writeln('      isFirstLaunch = false;')
      ..writeln('    }')
      ..writeln('    return server;')
      ..writeln('  });')
      ..writeln('}');

    final outputId = AssetId(buildStep.inputId.package, '.ruta/server.dart');
    await buildStep.writeAsString(outputId, buffer.toString());
  }
}
