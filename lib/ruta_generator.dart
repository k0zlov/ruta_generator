import 'package:build/build.dart';
import 'package:collection/collection.dart' show IterableExtension;
import 'package:glob/glob.dart';

/// Builder for generating Ruta routes
class RutaBuilder implements Builder {
  @override
  final buildExtensions = const {
    r'$package$': ['.ruta/server.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final routes = <String>[];
    final imports = <String>{
      "'package:ruta/ruta.dart'",
      "'dart:io'",
      "'package:get_it/get_it.dart'",
      "'package:${buildStep.inputId.package}/main.dart' as entrypoint",
      "'package:ruta/open_api.dart'",
      "'package:shelf_swagger_ui/shelf_swagger_ui.dart'",
    };

    final assetIds = await buildStep.findAssets(Glob('lib/**.dart')).toList();
    for (final assetId in assetIds) {
      if (!await buildStep.canRead(assetId)) {
        continue;
      }

      final isLib = await buildStep.resolver.isLibrary(assetId);
      if (!isLib) {
        continue;
      }

      final library = await buildStep.resolver.libraryFor(assetId);

      for (final element in library.definingCompilationUnit.classes) {
        if (element.metadata.any((meta) {
          final constant = meta.computeConstantValue();
          final typeName = constant?.type?.element?.name;
          return typeName == 'RutaRoute';
        })) {
          final routeType = element.allSupertypes.firstWhereOrNull(
            (t) =>
                t.element.name == 'Route' && t.element.library.name == 'ruta',
          );
          if (routeType == null) {
            throw Exception('${element.name} must implement Route');
          }

          final className = element.name;
          imports.add("'package:${element.source.uri.path}'");
          final constructor = element.constructors
                  .firstWhereOrNull((c) => c.isDefaultConstructor) ??
              element.constructors.first;

          final dependencies = constructor.parameters.map((param) {
            if (param.isNamed) {
              return '${param.name}: getIt()';
            } else {
              return 'getIt()';
            }
          }).join(', ');

          final routeInstance = dependencies.isEmpty
              ? '$className()'
              : '$className($dependencies)';

          routes.add(routeInstance);
        }
      }
    }

    final buffer = StringBuffer()
      ..writeln('// Generated by ruta_generator. DO NOT EDIT.')
      ..writeln();

    for (final imp in imports) {
      buffer.writeln('import $imp;');
    }

    buffer
      ..writeln()
      ..writeln('final getIt = GetIt.instance;')
      ..writeln()
      ..writeln('Handler createRouter() {')
      ..writeln('  final router = Router();')
      ..writeln('  try {')
      ..writeln('    final routes = <Route>[');

    for (final routeInstance in routes) {
      buffer.writeln('      $routeInstance,');
    }

    buffer
      ..writeln('    ];')
      ..writeln()
      ..writeln('    for (final route in routes) {')
      ..writeln(r"      router.mount('/${route.name}', route.build());")
      ..writeln('    }')
      ..writeln()
      ..writeln('    OpenApiSpec? spec;')
      ..writeln('    try {')
      ..writeln('      spec = getIt.get<OpenApiSpec>();')
      ..writeln('    } catch (e) {')
      ..writeln(r"      print('No OpenApiSpec registered in getIt: $e');")
      ..writeln('    }')
      ..writeln()
      ..writeln('    if (spec != null) {')
      ..writeln('      OpenApiGenerator.generate(spec, routes);')
      ..writeln('      final File openapiSpec = File(".ruta/openapi.json");')
      ..writeln(
        '      final swaggerUi = SwaggerUI.fromFile(openapiSpec, title: spec.info.title);',
      )
      ..writeln(
        "      router.mount('/api-docs', fromShelfHandler(swaggerUi.call));",
      )
      ..writeln('    }')
      ..writeln('  } catch (e) {')
      ..writeln(r"    print('Error initializing routes: $e');")
      ..writeln('  }')
      ..writeln('  return router.call;')
      ..writeln('}')
      ..writeln()
      ..writeln(
        'Future<HttpServer> createServer(InternetAddress address, int port) {',
      )
      ..writeln('  return entrypoint.run(createRouter, address, port);')
      ..writeln('}')
      ..writeln()
      ..writeln('void main() async {')
      ..writeln('  getIt.allowReassignment = true;')
      ..writeln('  await entrypoint.init();')
      ..writeln()
      ..writeln('  bool isFirstLaunch = true;') // Local flag for first launch
      ..writeln()
      ..writeln('  hotReload(() async {')
      ..writeln(
        "    final port = int.tryParse(Platform.environment['PORT'] ?? '8080') ?? 8080;",
      )
      ..writeln(
        '    final server = await createServer(InternetAddress.anyIPv4, port);',
      )
      ..writeln('    if (isFirstLaunch) {')
      ..writeln(
        r"      print('Server running on http://localhost:${server.port}');",
      )
      ..writeln('      isFirstLaunch = false;')
      ..writeln('    }')
      ..writeln('    return server;')
      ..writeln('  });')
      ..writeln('}');

    final outputId = AssetId(buildStep.inputId.package, '.ruta/server.dart');
    await buildStep.writeAsString(outputId, buffer.toString());
  }
}
